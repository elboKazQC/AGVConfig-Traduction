#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Main entry point for the Fault Editor application.

This module initializes the user interface and launches the complete
Fault Editor application with all original functionalities restored
in a modern modular architecture.

Author: AI Assistant
Created: 2024
"""

import os
import sys
import logging
import tkinter as tk
from tkinter import ttk, messagebox

# Import our complete modular controller
from main_controller import FaultEditorController

# Create logs directory
os.makedirs('logs', exist_ok=True)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] %(levelname)s - %(name)s: %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
    handlers=[
        logging.FileHandler('logs/app_complete.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)


# Legacy compatibility wrapper - Now simply delegates to the complete controller
class FaultEditor:
    """
    Legacy compatibility wrapper that provides the same interface as the original
    FaultEditor class. Now delegates everything to the complete FaultEditorController.
    """

    def __init__(self, root):
        """Initialize the wrapper with the complete controller."""
        logger.info("üîÑ Starting Fault Editor with complete modular interface")

        self.root = root
        self.controller = FaultEditorController(root)

        # Expose commonly used attributes for backward compatibility
        self.lang = self.controller.lang
        self.file_map = self.controller.file_map
        self.base_dir = self.controller.base_dir
        self.search_results = self.controller.search_results
        self.data_map = self.controller.data_map
        self.columns = self.controller.columns
        self.current_path = self.controller.current_path

        logger.info("‚úÖ Legacy wrapper initialized with complete modular backend")

    def __getattr__(self, name):
        """
        Delegate any unknown attribute access to the controller.
        This provides transparent access to all controller methods.
        """
        if hasattr(self.controller, name):
            return getattr(self.controller, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")


def main():
    """
    Main entry point for the complete Fault Editor application.

    Launches the application with all original functionalities restored
    in a modern modular architecture.
    """
    try:
        logger.info("üöÄ Starting Complete Fault Editor Application")

        root = tk.Tk()

        # Try to load Azure theme if available        try:
            root.tk.call('source', 'azure.tcl')
            root.tk.call('set_theme', 'dark')  # Use dark theme by default
            logger.info("Azure dark theme loaded successfully")
        except tk.TclError as e:
            logger.warning(f"Azure theme not loaded: {e}")
            print("WARNING: Azure theme not found. Using default theme.")

        # Choose between legacy wrapper and direct controller
        use_legacy_wrapper = os.environ.get('FAULT_EDITOR_LEGACY_MODE', 'true').lower() == 'true'

        if use_legacy_wrapper:
            logger.info("üì¶ Using legacy compatibility wrapper")
            app = FaultEditor(root)
        else:
            logger.info("üèóÔ∏è Using direct controller mode")
            app = FaultEditorController(root)

        # Setup cleanup handler
        def on_closing():
            try:
                if hasattr(app, 'cleanup'):
                    app.cleanup()
                logger.info("üîö Application closed successfully")
            except Exception as e:
                logger.error(f"Error during cleanup: {e}")
            finally:
                root.quit()
                root.destroy()

        root.protocol("WM_DELETE_WINDOW", on_closing)

        logger.info("‚úÖ Complete application initialized successfully")
        print("üéâ Fault Editor - Interface Compl√®te Restaur√©e!")
        print("üìö Toutes les fonctionnalit√©s originales sont maintenant disponibles")
        print("üèóÔ∏è Architecture modulaire avec interface compl√®te")
        print("üîß Pr√™t pour l'√©dition des codes de d√©faut AGV")

        # Start the main event loop
        root.mainloop()

    except ImportError as e:
        error_msg = f"‚ùå Erreur d'importation des modules: {e}"
        logger.error(error_msg)
        print(error_msg)
        print("üí° V√©rifiez que tous les modules sont pr√©sents")
        sys.exit(1)

    except Exception as e:
        error_msg = f"‚ùå Erreur fatale: {e}"
        logger.error(error_msg, exc_info=True)
        print(error_msg)

        # Try to show error dialog if tkinter is available
        try:
            import tkinter.messagebox as mb
            mb.showerror("Erreur Fatale", f"L'application n'a pas pu d√©marrer:\n\n{e}")
        except:
            pass

        sys.exit(1)


# Legacy compatibility: allow the file to be run directly
if __name__ == "__main__":
    main()
